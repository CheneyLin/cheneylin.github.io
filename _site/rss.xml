<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
<channel>
        <title>Cheney Lin</title>
        <description>Cheney Lin - Cheney Lin</description>
        <link>http://www.linchangyu.com</link>
        <link>http://www.linchangyu.com</link>
        <lastBuildDate>2014-12-05T18:27:22+08:00</lastBuildDate>
        <pubDate>2014-12-05T18:27:22+08:00</pubDate>
        <ttl>1800</ttl>


        <item>
                <title>轻应用开发设计规范</title>
                <description>
&lt;h2 id=&quot;section&quot;&gt;概述  &lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;定义:以微信传播为主要渠道的 HTML5 应用  &lt;/li&gt;
  &lt;li&gt;技术:HTML5、JS、CSS、Jquery、Zepto、collie  &lt;/li&gt;
  &lt;li&gt;资源:PSD、JPG、PNG、MP4、MP3、OGG  &lt;/li&gt;
  &lt;li&gt;设备:Google Nexus 5以上,三星Galaxy Notes以上,iPhone4以上  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-1&quot;&gt;设计交付&lt;/h2&gt;

&lt;h3 id=&quot;section-2&quot;&gt;文案&lt;/h3&gt;

&lt;p&gt;项目受众、整体风格、分页索引及说明  &lt;/p&gt;

&lt;h3 id=&quot;vi&quot;&gt;品牌 VI&lt;/h3&gt;

&lt;p&gt;图像、文字、图文布局、色彩风格  &lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;分页设计:     &lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;按页单独交付 PSD 格式分层文件  &lt;/li&gt;
  &lt;li&gt;文件宽高 800px*1200px  &lt;/li&gt;
  &lt;li&gt;内容区面积(元素最小显示区域)800px  *1040px   d) 内容排版方式为底部裁剪、上下裁剪、按比例分布  &lt;/li&gt;
  &lt;li&gt;动画设计:按帧提供单图序列(统一大小)和拼图(固定大 小左右拼凑)  &lt;/li&gt;
  &lt;li&gt;视频文件:兼容 iPhone 的 mp4 格式,不低于 480px*320px, 尽量分节以缩小单个文件容量  &lt;/li&gt;
  &lt;li&gt;音频文件:提供 2 声道 mp4、ogg 文件,尽量也提供 wav 源文件备用  &lt;/li&gt;
&lt;/ol&gt;
</description>
                <link>http://www.linchangyu.com/app/2014/12/05/html5-app-design-guide</link>
                <guid>http://www.linchangyu.com/app/2014/12/05/html5-app-design-guide</guid>
                <pubDate>2014-12-05T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>APP调用Custom URL Scheme</title>
                <description>
&lt;p&gt;Custom URL scheme 的好处就是，你可以在其它程序中通过这个url打开应用程序。如Ａ应用程序注册了一个url scheme:myApp,  那么就在mobile浏览器中就可以通过&amp;lt;href=’myApp://’&amp;gt;打开你的应用程序Ａ。&lt;/p&gt;

&lt;h2 id=&quot;android&quot;&gt;Android&lt;/h2&gt;

&lt;p&gt;首先在AndroidManifast.xml要被指定Scheme的Activity下设置如下参数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;intent-filter&amp;gt;  
  &amp;lt;category android:name=&quot;android.intent.category.DEFAULT&quot;&amp;gt;&amp;lt;/category&amp;gt;  
  &amp;lt;action android:name=&quot;android.intent.action.VIEW&quot;&amp;gt;&amp;lt;/action&amp;gt;  
  &amp;lt;data android:scheme=&quot;mgtv&quot;&amp;gt;&amp;lt;/data&amp;gt;  
&amp;lt;/intent-filter&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样即指定了接收Uri的Scheme为 mgtv 且 Action为View的Intent。&lt;/p&gt;

&lt;p&gt;利用如下Intent调用Activity&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;startActivity(new Intent(Intent.ACTION_VIEW, Uri.parse(&quot;mgtv://?action=play&amp;amp;data=12345&quot;)));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或在浏览器中调用A链接打开&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;a href=&quot;mgtv://?action=play&amp;amp;data=12345&quot;&amp;gt;打开你的应用程序&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在接收的Activity中使用如下代码获得数据&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//获得Scheme名称  
this.getIntent().getScheme();
//获得Uri全部路径
this.getIntent().getDataString();
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;ios&quot;&gt;iOS&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/images/xcodeurlscheme.jpg&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如果没有URL types，随意点一个key行后面＋号，输入大写URL选择URL types&lt;/li&gt;
  &lt;li&gt;右键URL types，选择add row&lt;/li&gt;
  &lt;li&gt;item0下改成url identifier，后面的value值随意写，com.xx,xx&lt;/li&gt;
  &lt;li&gt;加一行，选择url schemes，item后面值写成你需要的，譬如上面的todolist&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在其他应用里就可以用以下语句启动你的app&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@&quot;todolist://&quot;]];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在自定义了 URL scheme 的应用中，app delegate 必须实现以下方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url
                                       sourceApplication:(NSString *)sourceApplication
                                              annotation:(id)annotation
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例如，假设我们使用以下的 URL scheme，我们可以像这样创建一个 URL：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NSString *customURL = @&quot;mgtv://?action=play&amp;amp;data=12345&quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 web 开发中，字符串 ?action=play&amp;amp;data=12345 被称作查询询串(query string)。&lt;/p&gt;

&lt;p&gt;在被调用(设置了自定义 URL)的应用的 app delegate 中，获取参数的代码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url
                                       sourceApplication:(NSString *)sourceApplication
                                              annotation:(id)annotation
{
  NSLog(@&quot;Calling Application Bundle ID: %@&quot;, sourceApplication);
  NSLog(@&quot;URL scheme:%@&quot;, [url scheme]);
  NSLog(@&quot;URL query: %@&quot;, [url query]);

  return YES;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上代码在应用被调用时的输出为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Calling Application Bundle ID: com.hunantv.app
URL scheme:mgtv
URL query: action=play&amp;amp;data=12345
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section&quot;&gt;额外功能&lt;/h3&gt;

&lt;p&gt;果处理成功的Scheme如包含了TestBAPP://callsuccess，那么说明你调用其他的APP成功了。
如果不是，那么说明是别的APP如TestAAPP调用了你的APP，此时在你的APPDelegate里面添加如下函数以及实现处理，这里是直接返回告诉TestAAPP调用成功的标识TestAAPP://callsuccess：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (BOOL)application:(UIApplication *)application handleOpenURL:(NSURL *)url  
{  
    // Do something with the url here  
    if (!url)  
    {  
        return NO;  
    }  
    NSString *handleUrl = [url absoluteString];  
    if ([handleUrl isEqualToString:@&quot;TestBApp://callsuccess&quot;]) {  
        return YES;  
    }else{  
        NSString *urlstr = @&quot;TestAAPP:/com.baidu.sidepath.TestA&amp;amp;_callback=TestAApp://callsuccess&quot;;  
        NSURL *handlbackeUrl = [NSURL URLWithString:urlstr];  
        [[UIApplication sharedApplication] openURL:handlbackeUrl];  

    }
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你不想直接返回callback，而是想启动一个页面那么，此时要考虑你的应用是否已经启动，可以如下判断使用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url  
  sourceApplication:(NSString *)sourceApplication annotation:(id)annotation{  
    NSString *handleUrl = [url absoluteString];  
    if ([handleUrl isEqualToString:@&quot;TestBApp://callsuccess&quot;]) {  
        return YES;  
    }else{  
        UINavigationController *vc = (UINavigationController *)_window.rootViewController;  
        if (vc == nil) {  
            PathViewController *controller = [[PathViewController alloc] initWithNibName:@&quot;PathViewController&quot; bundle:nil];  

            self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];  
            self.mUINavigationController = [[UINavigationController alloc] init];  


            [self.mUINavigationController pushViewController:controller animated:YES];  
            [self.window addSubview:self.mUINavigationController.view];  


            // Override point for customization after application launch.  
            self.window.backgroundColor = [UIColor whiteColor];  
            [self.window makeKeyAndVisible];  
        }  
        return YES;  
    }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也就是把appdelegate里面的didFinishLaunchingWithOptions初始化app的代码拷贝进去。此时会启动PathViewController这个页面。然后在这个页面里面可以添加一个返回按钮来返回到调用APP。&lt;/p&gt;

&lt;p&gt;再次 在TestAAPp里面使用URl Scheme调起你的APP&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (void)buttonPressed:(UIButton *)button
{
  NSString *customURL = @&quot;mgtv://play/12345&quot;;

  if ([[UIApplication sharedApplication]
    canOpenURL:[NSURL URLWithString:customURL]])
  {
    [[UIApplication sharedApplication] openURL:[NSURL URLWithString:customURL]];
  }
  else
  {
    UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@&quot;URL error&quot;
                          message:[NSString stringWithFormat:
                            @&quot;No custom URL defined for %@&quot;, customURL]
                          delegate:self cancelButtonTitle:@&quot;Ok&quot;
                          otherButtonTitles:nil];
    [alert show];
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看更多苹果官方资料：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIApplicationDelegate_Protocol/Reference/Reference.html&quot;&gt;https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIApplicationDelegate_Protocol/Reference/Reference.html&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;其他&lt;/h2&gt;

&lt;p&gt;iOS与Android在这儿有点小区别，在iOS中如果系统注册了url scheme且安装了那个应用程序，通过上面那种网页的方式就可以启动应用程序，如果没有注册或没有安装那个应用程序，就没有任何效果（你注册的url scheme不能是http://xxx 这样的）。&lt;/p&gt;

&lt;p&gt;在Android系统中注册了url scheme且安装了那个应用程序，通过上面那种网页的方式就可以启动应用程序，如果没有注册或没有安装那个应用程序，就没有任何效果；如果注册了是http://xxx这样的，就会弹了一个对话框让你选，是打开网页还是程序。&lt;/p&gt;

&lt;p&gt;iOS中不能注册http://xxx这样的url scheme,而Android是可以的。&lt;/p&gt;
</description>
                <link>http://www.linchangyu.com/app/2014/12/01/app-url-scheme</link>
                <guid>http://www.linchangyu.com/app/2014/12/01/app-url-scheme</guid>
                <pubDate>2014-12-01T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>开源的js/css框架（收集中）</title>
                <description>
&lt;p&gt;国内的互联网企业有许多开源项目，其中就包括前端的很多优秀框架，摘录如下：&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;网易&lt;/h2&gt;

&lt;h3 id=&quot;nec&quot;&gt;NEC&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://nec.netease.com/&quot;&gt;http://nec.netease.com/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;网易员工开源的CSS框架，特别是整理出一套规范，很值得研究。&lt;/p&gt;

&lt;h3 id=&quot;nej&quot;&gt;NEJ&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://nej.netease.com/&quot;&gt;http://nej.netease.com/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;更好的JS解决方案，有点复杂，其中JS底层的一些架构技术值得学习。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;依赖管理&lt;/p&gt;

    &lt;p&gt;优化开发阶段脚本文件依赖关系管理，所有脚本按需打包发布，上线产品分离依赖因此无任依赖相关开销&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;平台适配&lt;/p&gt;

    &lt;p&gt;支持桌面及移动平台、浏览器及混合应用开发，补丁模式无缝扩展适配平台，配置方式灵活定制目标平台&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;自由定制&lt;/p&gt;

    &lt;p&gt;按实际需求定制脚本，支持多种定制方式，包括按平台定制、按功能定制、按模块定制等&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;方案集成&lt;/p&gt;

    &lt;p&gt;多种实践解决方案集成，包括多类型前端模板方案、按需载入模块化调度方案、多模式切换跨域数据通讯方案等等&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;控件体系&lt;/p&gt;

    &lt;p&gt;支持便捷api调用，同时也支持产品自由扩展定制，集高度重用与灵活扩展于一体&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;工具支持&lt;/p&gt;

    &lt;p&gt;一键产品打包发布，优化产品输出，自动版本管理；工具支持项目迁移使用依赖系统及打包工具；&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;腾讯&lt;/h2&gt;

&lt;h3 id=&quot;web&quot;&gt;移动Web整体应用方案&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://alloyteam.github.io/Spirit/&quot;&gt;http://alloyteam.github.io/Spirit/&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;移动Web开发规范&lt;/p&gt;

    &lt;p&gt;移动Web开发规范，基于日常开发的沉淀，总结了字体、交互、性能等方面的最佳实践，是移动Web开发的指导标准。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;JM(JavaScript Mobile)&lt;/p&gt;

    &lt;p&gt;JM(JavaScript Mobile)，轻量级高性能JavaScript基础库，经实践项目积累沉淀而成。为拥抱移动互联网设计，专注移动web项目。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;JMUI(Based on JM)&lt;/p&gt;

    &lt;p&gt;JMUI，建立在JM的UI组件库，基于HTML5与CSS3，涵盖了目前互联网上各类常见的UI组件，可方便地投入项目使用。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;css3&quot;&gt;css3动画库&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://css3lib.alloyteam.com/&quot;&gt;http://css3lib.alloyteam.com/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这个只是收集CSS3特效的一个集合，但是很实用。&lt;/p&gt;

&lt;p&gt;更多腾讯前端工具请访问 博客主页&lt;a href=&quot;http://www.AlloyTeam.com/&quot;&gt;http://www.AlloyTeam.com/&lt;/a&gt;或项目清单&lt;a href=&quot;http://alloyteam.github.io/&quot;&gt;http://alloyteam.github.io/&lt;/a&gt;。&lt;/p&gt;
</description>
                <link>http://www.linchangyu.com/web/2014/11/27/opensource-js-css-framewok</link>
                <guid>http://www.linchangyu.com/web/2014/11/27/opensource-js-css-framewok</guid>
                <pubDate>2014-11-27T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>HTML5实现视频的分离显示</title>
                <description>
&lt;p&gt;HTML5中的canvas可以实现很多图像、多媒体方面的功能，比如把视频的内容二次处理后在canvas上显示。&lt;/p&gt;

&lt;h2 id=&quot;drawimage&quot;&gt;强大的drawImage&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;var video = document.querySelector(&#39;video&#39;);
var canvas1 = document.querySelector(&#39;#canvas1&#39;);
var ctx1 = canvas1.getContext(&#39;2d&#39;);
ctx1.drawImage(video, 0,0, 320, 180, 0,0, 320, 180);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完整代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;html &amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta charset=&quot;utf-8&quot; /&amp;gt;
&amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;

&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;div style=&quot;position:absolute;&quot;&amp;gt;
    &amp;lt;input type=&quot;button&quot; id=&quot;play&quot; value=&quot;play&quot;&amp;gt;
    &amp;lt;span id=&quot;position&quot;&amp;gt;00:00&amp;lt;/span&amp;gt; / &amp;lt;span id=&quot;duration&quot;&amp;gt;&amp;lt;/span&amp;gt;
&amp;lt;/div&amp;gt;
  &amp;lt;div style=&quot;position:absolute;top:350px;display:none;&quot;&amp;gt;
   &amp;lt;video width=&quot;848&quot; height=&quot;480&quot; loop&amp;gt;
    &amp;lt;source src=&quot;test.mp4&quot; type=&quot;video/mp4&quot;/&amp;gt;
  &amp;lt;/video&amp;gt;

&amp;lt;/div&amp;gt;
&amp;lt;div style=&quot;position:absolute;left:10px;top:50px;&quot;&amp;gt;
  &amp;lt;canvas id=&quot;canvas1&quot; width=&quot;320&quot; height=&quot;180&quot;&amp;gt;&amp;lt;/canvas&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;div style=&quot;position:absolute;left:350px;top:50px;&quot;&amp;gt;
  &amp;lt;canvas id=&quot;canvas2&quot; width=&quot;320&quot; height=&quot;180&quot;&amp;gt;&amp;lt;/canvas&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;div style=&quot;position:absolute;left:10px;top:250px;&quot;&amp;gt;
  &amp;lt;canvas id=&quot;canvas3&quot; width=&quot;320&quot; height=&quot;180&quot;&amp;gt;&amp;lt;/canvas&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;div style=&quot;position:absolute;left:350px;top:250px;&quot;&amp;gt;
  &amp;lt;canvas id=&quot;canvas4&quot; width=&quot;320&quot; height=&quot;180&quot;&amp;gt;&amp;lt;/canvas&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;div style=&quot;position:absolute;left:10px;top:450px;&quot;&amp;gt;
  &amp;lt;canvas id=&quot;canvas5&quot; width=&quot;320&quot; height=&quot;180&quot;&amp;gt;&amp;lt;/canvas&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;div style=&quot;position:absolute;left:350px;top:450px;&quot;&amp;gt;
  &amp;lt;canvas id=&quot;canvas6&quot; width=&quot;320&quot; height=&quot;180&quot;&amp;gt;&amp;lt;/canvas&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;script &amp;gt;

    var addEvent = (function () {
        if (document.addEventListener) {
            return function (el, type, fn) {
                if (el &amp;amp;&amp;amp; el.nodeName || el === window) {
                    el.addEventListener(type, fn, false);
                } else if (el &amp;amp;&amp;amp; el.length) {
                    for (var i = 0; i &amp;lt; el.length; i++) {
                        addEvent(el[i], type, fn);
                    }
                }
            };
        } else {
            return function (el, type, fn) {
                if (el &amp;amp;&amp;amp; el.nodeName || el === window) {
                    el.attachEvent(&#39;on&#39; + type, function () { return fn.call(el, window.event); });
                } else if (el &amp;amp;&amp;amp; el.length) {
                    for (var i = 0; i &amp;lt; el.length; i++) {
                        addEvent(el[i], type, fn);
                    }
                }
            };
        }
    })();

&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
    var video = document.querySelector(&#39;video&#39;);
    var togglePlay = document.querySelector(&#39;#play&#39;);
    var position = document.querySelector(&#39;#position&#39;);
    var canvas1 = document.querySelector(&#39;#canvas1&#39;);
    var ctx1 = canvas1.getContext(&#39;2d&#39;);
    var canvas2 = document.querySelector(&#39;#canvas2&#39;);
    var ctx2 = canvas2.getContext(&#39;2d&#39;);
    var canvas3 = document.querySelector(&#39;#canvas3&#39;);
    var ctx3 = canvas3.getContext(&#39;2d&#39;);
    var canvas4 = document.querySelector(&#39;#canvas4&#39;);
    var ctx4 = canvas4.getContext(&#39;2d&#39;);
    var canvas5 = document.querySelector(&#39;#canvas5&#39;);
    var ctx5 = canvas5.getContext(&#39;2d&#39;);
    var canvas6 = document.querySelector(&#39;#canvas6&#39;);
    var ctx6 = canvas6.getContext(&#39;2d&#39;);
var vleft=10;
var vtop=80;
var vmargin=4;
var vwidth=392;
var vheight=156;
var canvaswidth=320;
var canvasheight=180;
    addEvent(togglePlay, &#39;click&#39;, function () {
        //video.playbackRate = 1;
        if (video.paused) {
            if (video.ended) video.currentTime = 0;
            video.play();
            this.value = &quot;pause&quot;;
        } else {
            video.pause();
            this.value = &quot;play&quot;;
        }
    });

    setInterval(function () {
        position.innerHTML = asTime(video.currentTime);
        ctx1.drawImage(video, vleft,vtop, vwidth, vheight, 0,0, canvaswidth, canvasheight);
        ctx2.drawImage(video, vleft+vwidth+vmargin,vtop, vwidth, vheight, 0,0, canvaswidth, canvasheight);
        ctx3.drawImage(video, vleft+vwidth*2+vmargin,vtop, vwidth, vheight, 0,0, canvaswidth, canvasheight);
        ctx4.drawImage(video, vleft, vtop+vheight+vmargin, vwidth, vheight, 0,0, canvaswidth, canvasheight);
        ctx5.drawImage(video, vleft+vwidth+vmargin,vtop+vheight+vmargin, vwidth, vheight, 0,0, canvaswidth, canvasheight);
        ctx6.drawImage(video, vleft+vwidth*2+vmargin,vtop+vheight+vmargin, vwidth, vheight, 0,0, canvaswidth, canvasheight);
    }, 1000 / 25);

    addEvent(video, &#39;ended&#39;, function () {
        togglePlay.value = &quot;play&quot;;
    });

    addEvent(video, &#39;canplay&#39;, function () {
        video.muted = true;
        document.querySelector(&#39;#duration&#39;).innerHTML = asTime(this.duration);
        startCanvas();
    });


    function startCanvas() {
        //canvas.setAttribute(&#39;height&#39;, Math.floor(video.height));
        //canvas.setAttribute(&#39;width&#39;, Math.floor(video.width));

        //ctx.translate(0, canvas.height );
        //ctx.scale(1, -1);
        //ctx.globalAlpha = 0.3;
        ctx1.drawImage(video, vleft,vtop, vwidth, vheight, 0,0, canvaswidth, canvasheight);
        ctx2.drawImage(video, vleft+vwidth+vmargin,vtop, vwidth, vheight, 0,0, canvaswidth, canvasheight);
        ctx3.drawImage(video, vleft+vwidth*2+vmargin,vtop, vwidth, vheight, 0,0, canvaswidth, canvasheight);
        ctx4.drawImage(video, vleft, vtop+vheight+vmargin, vwidth, vheight, 0,0, canvaswidth, canvasheight);
        ctx5.drawImage(video, vleft+vwidth+vmargin,vtop+vheight+vmargin, vwidth, vheight, 0,0, canvaswidth, canvasheight);
        ctx6.drawImage(video, vleft+vwidth*2+vmargin,vtop+vheight+vmargin, vwidth, vheight, 0,0, canvaswidth, canvasheight);


    }

    function asTime(t) {
        t = Math.round(t);
        var s = t % 60;
        var m = Math.round(t / 60);

        return two(m) + &#39;:&#39; + two(s);
    }

    function two(s) {
        s += &quot;&quot;;
        if (s.length &amp;lt; 2) s = &quot;0&quot; + s;
        return s;
    }
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://www.linchangyu.com/web/2014/11/27/html5-video-canvas-show</link>
                <guid>http://www.linchangyu.com/web/2014/11/27/html5-video-canvas-show</guid>
                <pubDate>2014-11-27T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>苹果iOS5下的的NSJSONSerialization类</title>
                <description>
&lt;p&gt;在iOS 5 中，苹果引入了一个解析JSON串的NSJSONSerialization类。
通过该类，我们可以完成JSON数据与NSDictionary和NSArray之间的转化。&lt;/p&gt;

&lt;p&gt;以前，我记得我用的是第三方的插件。但是，苹果出了这套解析后，效率也大大了超过了其他的JSON解析第三方类库。所以，推荐使用NSJSONSerialization类来完成转化。&lt;/p&gt;

&lt;h2 id=&quot;nsdictionarynsarrayjson&quot;&gt;将NSDictionary或NSArray转化为JSON串&lt;/h2&gt;

&lt;p&gt;将字典或者数组转化为JSON串&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (NSData *)toJSONData:(id)theData{

    NSError *error = nil;
    NSData *jsonData = [NSJSONSerialization dataWithJSONObject:theData
                                                       options:NSJSONWritingPrettyPrinted
                                                         error:&amp;amp;error];

    if ([jsonData length] &amp;gt; 0 &amp;amp;&amp;amp; error == nil){
        return jsonData;
    }else{
        return nil;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用这个方法的返回，我们就可以得到想要的JSON串&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NSString *jsonString = [[NSString alloc] initWithData:jsonData
                                             encoding:NSUTF8StringEncoding];
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;jsonnsdictionarynsarray&quot;&gt;将JSON串转化为NSDictionary或NSArray&lt;/h2&gt;

&lt;p&gt;将NSString转化为NSData&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[jsonString dataUsingEncoding:NSASCIIStringEncoding];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将JSON串转化为字典或者数组&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (id)toArrayOrNSDictionary:(NSData *)jsonData{
    NSError *error = nil;
    id jsonObject = [NSJSONSerialization JSONObjectWithData:jsonData
                                                    options:NSJSONReadingAllowFragments
                                                      error:&amp;amp;error];

    if (jsonObject != nil &amp;amp;&amp;amp; error == nil){
        return jsonObject;
    }else{
        // 解析错误
         return nil;
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;jsonnsarraynsdictionary&quot;&gt;将JSON串与NSArray和NSDictionary的操作进行封装&lt;/h2&gt;

&lt;p&gt;当然，也有很多时候，我们将这些操作，分别定义在NSObject和NSString的一个分类中&lt;/p&gt;

&lt;p&gt;直接贴：&lt;/p&gt;

&lt;h3 id=&quot;nsstringnsarraynsdictionary&quot;&gt;将NSString转化为NSArray或者NSDictionary&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#import &quot;NSString+JSONCategories.h&quot;
@implementation NSString(JSONCategories)
-(id)JSONValue;
{
    NSData* data = [self dataUsingEncoding:NSUTF8StringEncoding];
    __autoreleasing NSError* error = nil;
    id result = [NSJSONSerialization JSONObjectWithData:data
                                                options:kNilOptions
                                                  error:&amp;amp;error];
    if (error != nil) return nil;
    return result;
}
@end
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;nsarraynsdictionarynsstring&quot;&gt;将NSArray或者NSDictionary转化为NSString&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;import &quot;NSObject+JSONCategories.h&quot;
@implementation NSObject (JSONCategories)
-(NSData*)JSONString;
{
    NSError* error = nil;
    id result = [NSJSONSerialization dataWithJSONObject:self
                                                options:kNilOptions
                                                  error:&amp;amp;error];
    if (error != nil) return nil;
    return result;
}
@end
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://www.linchangyu.com/ios/2014/11/26/xcode-json-nsstring-convert</link>
                <guid>http://www.linchangyu.com/ios/2014/11/26/xcode-json-nsstring-convert</guid>
                <pubDate>2014-11-26T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>苹果iOS系统下的推送机制及实现</title>
                <description>
&lt;p&gt;&lt;em&gt;本文译自&lt;a href=&quot;http://www.raywenderlich.com&quot;&gt;http://www.raywenderlich.com&lt;/a&gt;。原文由iOS教程团队 Matthijs Hollemans 撰写，经原网站管理员授权本博翻译。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;在iOS系统，考虑到手机电池电量，应用不允许在后台进行过多的操作，当用户未开启应用时，要怎么样才能通知用户呢？&lt;/p&gt;

&lt;p&gt;好比用户收到一个新的微博、喜欢的球队取得一场胜利或者是晚餐准备好了，如果应用都不在运行当中，当然也就无法去获得这些事件。&lt;/p&gt;

&lt;p&gt;幸运的是苹果提供一个解决方案，通过你自己的服务组件来替代应用持续地检查事件或在后台进行类似的操作，当事件实时发生时，服务组件能发送通知给应用，通过下列三种方式提醒用户：&lt;/p&gt;

&lt;p&gt;显示简短的文本作息，播放提示音，在应用图标上显示数字提示（就是红色背景的那个）&lt;/p&gt;

&lt;p&gt;你可以把这三种方式随便地组合使用，比如播放声音并显示一个提示数字而已。&lt;/p&gt;

&lt;p&gt;在本教程中，你可以用APNS（Apple Push Notification Services）来开发一个简单的应用。&lt;/p&gt;

&lt;p&gt;我们先来学习一下在应用开发中如何设置接收推送通知，如何接收一条测试通知。&lt;/p&gt;

&lt;p&gt;本教程针对的是有一些经验的iOS开发者，初学者请在先选择一些初级教程：&lt;/p&gt;

&lt;p&gt;目录：&lt;a href=&quot;http://www.raywenderlich.com/tutorials&quot;&gt;raywenderlich.com/tutorials&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;特别是这两篇：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.raywenderlich.com/2941/how-to-write-a-simple-phpmysql-web-service-for-an-ios-app&quot;&gt;How To Write A Simple PHP/MySQL Web Service for an iOS App&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.raywenderlich.com/2965/how-to-write-an-ios-app-that-uses-a-web-service&quot;&gt;How To Write an iOS App That Uses A Web Service&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;准备好了吗，让我们开始吧：&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;基本框架&lt;/h2&gt;

&lt;p&gt;要让苹果推送通知服务正常工作，涉及很多方面，下图是一个基本框架：&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;Apple Push Notification Services (APNS) Overview&quot; src=&quot; /images/2014/Push-Overview-467x500.jpg&quot; alt=&quot;Apple Push Notification Services (APNS) Overview&quot; width=&quot;467&quot; height=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;应用启用推送通知功能，需要用户确认；&lt;/li&gt;
  &lt;li&gt;应用收到设备识别ID（device token），相当于接收推送通知的地址；&lt;/li&gt;
  &lt;li&gt;应用将设备识别ID发送到你开发的服务器；&lt;/li&gt;
  &lt;li&gt;当有推送通知的需要时，你就可以通过你开发的服务组件发送信息到苹果的服务器上；&lt;/li&gt;
  &lt;li&gt;苹果推送通知服务将信息推送到用户的设备上。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;用户设备接收到推送信息时，显示提示信息或播放提示音或更新主屏图标的提示数字，用户可以从提示信息窗口打开应用程序，应用可以根据提示信息的内容作进一步的处理。&lt;/p&gt;

&lt;p&gt;iOS4支持本地通知和后台多任务，是否我们就不需要推送通知了呢？&lt;/p&gt;

&lt;p&gt;答案是否定的，本地通知仅限于周期性定时事件处理，后台多任务也仅限于一些必须保持运行的应用，比如IP语音、后台音乐播放、导航等，如果你需要在你的应用关闭时提醒你的用户，你就必须使用推送通知服务
接下来，我们来探讨一些实现苹果推送通知服务的技术细节，内容比较多，泡好一杯咖啡，安静认真地阅读本教程吧。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;苹果推送通知服务的目的&lt;/h2&gt;

&lt;p&gt;在你的应用中增加苹果推送通知服务有以下几项准备工作：&lt;/p&gt;

&lt;p&gt;一台iPhone或iPad，苹果推送通知服务不能在模拟器上工作，你必须在真机上测试；&lt;/p&gt;

&lt;p&gt;你得有付费开通的iOS开发者会员资格，你必须在苹果开发者门户（iOS Provisioning Portal）新增一个新的应用ID、对应的配置文件（provisioning profile）、专属于你的SLL认证证书；在整个过程中，你将创建自己的配置文件和证书，获取认证证书是很慎重的过程，必须按照规定执行，后文中有详细的操作步骤；&lt;/p&gt;

&lt;p&gt;一台联入互联网的服务器，苹果推送通知服务是在互联网上工作，开发时你可以在你的工作站上测试，但是实际使用时，你至少需要一台虚拟个人服务器，但是要保证可以安装证书，并开放相应的端口与苹果的服务器建立安全套接字（TLS）网络连接，一般IDC虚拟空间提供商不会提供此类额外服务，请先与你的供应商确认这些细节；
当然，还有专门提供苹果推送通知服务的网络服务商，你可以自行谷歌之，本文不讨论。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;推送通知格式&lt;/h2&gt;

&lt;p&gt;你的服务器组件将根据事件或需要创建推送通知，你得先了解推送通知的具体格式；&lt;/p&gt;

&lt;p&gt;一个推送通知包括设备识别ID，通知主体和一些标识字节，通知主体是我们要发送的内容。&lt;/p&gt;

&lt;p&gt;首先我们得按JSON格式组织好通知主体，下面是一个最简单的示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &quot;aps&quot;:
  {
    &quot;alert&quot;:&quot;测试信息&quot;,
    &quot;sound&quot;:&quot;default&quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用大括号｛｝将键值对（字典对象）封装起来，有点像NSDictionary。&lt;/p&gt;

&lt;p&gt;通知主体至少得包括一个项目：”aps”，这个项的内容还是一个字典对象，在上面这个示例中，”aps”包括两个字段：alert和sound，让设备收到这个推送通知时，设备会弹出一个提示窗口，内容是测试信息，同时播放标准的提示声音。&lt;/p&gt;

&lt;p&gt;在aps这个字段下我们还可以自定义一些内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &quot;aps&quot;:
  {
    &quot;alert&quot;:
    {
      &quot;action-loc-key&quot;:&quot;Open&quot;,
      &quot;body&quot;:&quot;Hello, world!&quot;
      },
    &quot;badge&quot;:2
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这个示例中，字段”alert”也变成一个字典对象，字段”action-loc-key”重新定义弹出提示窗口中确认按钮上的文字，”badge”字段是需要在主屏图标上显示的提示数字，这个示例没有播放声音。&lt;/p&gt;

&lt;p&gt;还有很多通知主体内容的设置方式，你可以改变播放的声音，可以根据本地语言化的调置提供本地化的提示文字，甚至于加上你自定义的字段内容。更多资料请移至官方&lt;a href=&quot;http://developer.apple.com/library/ios/#documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/Introduction/Introduction.html&quot;&gt;《本地和推送通知开发指引（英）》&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;出于效率的考虑，推送通知的字节长度不能超过256个字节，类似于短信或推特（微博），所以在组织JSON通知主体内容时，一般我们都不保留换行和空格：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
  &quot;aps&quot;:
  {
    &quot;alert&quot;:&quot;Hello, world!&quot;,
    &quot;sound&quot;:&quot;default&quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样已经很清楚了，不是吗，超过256个字节的推送通知，苹果的服务器可是会自动过滤掉的。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;正式开始&lt;/h2&gt;

&lt;p&gt;&lt;img title=&quot;Push Notifications Are Unreliable!&quot; src=&quot; /images/2014/PushNotifWhy-250x187.jpg&quot; alt=&quot;Push Notifications Are Unreliable!&quot; width=&quot;250&quot; height=&quot;187&quot; /&gt;&lt;/p&gt;

&lt;p&gt;推送通知不保证发送接收的可靠性！！？？&lt;/p&gt;

&lt;p&gt;是的，就算APNS接收发送的请求，推送通知的接收也是没有保证的。&lt;/p&gt;

&lt;p&gt;认真考虑你的应用是否适用推送通知，现在没有办法确认推送通知发送的状态和接收与否，发送时间也无法得到保证，可能几秒也可以半小时。&lt;/p&gt;

&lt;p&gt;而且，如果用户设备通过受限的局域网在线或处于关机状态，也是收不到推送通知的。&lt;/p&gt;

&lt;p&gt;APNS会尝试在设备重新上线时发送最后一条推送通知，但是这种尝试不会持续太长时间，之后推送通知就永远失效了。&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;After looking at the APNS Server Bill&quot; src=&quot; /images/2014/RageFace-250x197.jpg&quot; alt=&quot;After looking at the APNS Server Bill&quot; width=&quot;250&quot; height=&quot;197&quot; /&gt;&lt;/p&gt;

&lt;p&gt;别指望在APNS里查找历史记录
发送推送通知的成本可能比你估计的要高！增加这个功能很简单，但是要维护一个比较大的用户群或一些特殊应用场合时，你可能需要承担较高的成本。&lt;/p&gt;

&lt;p&gt;只要监控你网站上的更新，并发送通知到你的用户是比较简单的，但是如果你提供的功能包括自定义监控其他网站的更新时，你的服务器要能够运行得了可能远超过你估计的监控任务。&lt;/p&gt;

&lt;p&gt;所以你还必须从维护成本上考虑你的应用是否需要这功能。&lt;/p&gt;

&lt;p&gt;好了，理论性的东西就这么多了，现在是时候来实践一下了。在编写代码之前，你还需要在苹果的开发者门户网站上处理一些烦人的步骤。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;配置文件和证书&lt;/h2&gt;

&lt;p&gt;我勒个去！&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;APNS needs a certificate!&quot; src=&quot; /images/2014/Screen-shot-2011-05-09-at-5.11.18-PM-250x87.jpg&quot; alt=&quot;APNS needs a certificate!&quot; width=&quot;250&quot; height=&quot;87&quot; /&gt;&lt;/p&gt;

&lt;p&gt;APNS需要认证证书！&lt;/p&gt;

&lt;p&gt;要在你的应用中启用推送功能，一个对应的配置文件是必不可少的，你需要用它来跟APNS确认APP，不是吗？&lt;/p&gt;

&lt;p&gt;配置文件和证书只能通过对应有效的苹果开发者计划成员来取得，这样才能保证只有你的服务组件才能发推送通知到你的应用。&lt;/p&gt;

&lt;p&gt;如果你有过开发经验，你知道应用配置文件分为开发和发布两种类型，推送配置文件也有两种：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;开发（Development）.对应着你开发测试时用的应用配置文件&lt;/li&gt;
  &lt;li&gt;发布（Production）.对应着你正式发布时用的应用配置文件&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在本教程中，我们只要关注开发配置文件即可。&lt;/p&gt;

&lt;h2 id=&quot;certificate-signing-request&quot;&gt;准备证书申请文件（Certificate Signing Request）&lt;/h2&gt;

&lt;p&gt;还记得初次通过苹果开发者门户获取开发证书的过程吗？下面的过程你应该会觉得比较熟悉。但是还是要认真地浏览其中的细节，大多数故障问题都跟证书有关。&lt;/p&gt;

&lt;p&gt;数字证书基于公私钥加密方式，这里我们并不需要了解加密的过程，你只要了解数字证书总是和个人私钥文件合并使用就行了。证书是公钥的部分，用于建立基于SSL的加密网络连接，并不需要高强度的保密，而私钥不同，这是”私的”，你需要好好地保存。&lt;/p&gt;

&lt;p&gt;要申请数字认证，你需要先准备一个证书申请文件（CSR），准备好后会在”钥匙串”程序（MAC OS）中生成一个新的私钥项目，把证书申请文件发给证书发放方（这里是苹果开发者门户），你将可以获取一个对应的SSL证书。&lt;/p&gt;

&lt;p&gt;在你的MAC电脑上的【应用程序/实用工具】下打开”钥匙串访问”程序（Applications/Utilities/Keychain Access），在【Keychain Access/Certificate Assistant】菜单中选择【Request a Certificate from a Certificate Authority…】&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;Requesting a certificate with Keychain Access&quot; src=&quot; /images/2014/Keychain-Access-1-Request-Certificate-500x200.jpg&quot; alt=&quot;Requesting a certificate with Keychain Access&quot; width=&quot;500&quot; height=&quot;200&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果你没有找到这个菜单项或是提示”Request a Certificate from a Certificate Authority with key”，你还需要额外在开发者门户里下载并安装&lt;a href=&quot;https://developer.apple.com/certificationauthority/AppleWWDRCA.cer&quot;&gt;WWDR Intermediate Certificate&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;确认没有选中窗口列表中的任何私钥，你应该可以看到以下窗口：&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;Generating a certificate sign request with Keychain Access&quot; src=&quot; /images/2014/Keychain-Access-2-Generate-CSR-500x370.jpg&quot; alt=&quot;Generating a certificate sign request with Keychain Access&quot; width=&quot;500&quot; height=&quot;370&quot; /&gt;&lt;/p&gt;

&lt;p&gt;输入你的邮件地址，虽然有人建议说最好是跟开发资格的用户一致，但是看起来不一样也没有关系。&lt;/p&gt;

&lt;p&gt;输入PushChat（示例应用名称）在common name 项，实际上随便你填什么，只要你到时能够通过命名找到你的私钥就行。&lt;/p&gt;

&lt;p&gt;选择【保存在本地磁盘（Saved to disk）】，将CSR保存为”PushChat.certSigningRequest”。&lt;/p&gt;

&lt;p&gt;现在你在”钥匙串访问”程序中Keys分类下应该可以找到一个新的私钥项目，右击并选择Export。&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;Exporting your private key with keychain access&quot; src=&quot; /images/2014/Keychain-Access-3-Export-Private-Key-500x279.jpg&quot; alt=&quot;Exporting your private key with keychain access&quot; width=&quot;500&quot; height=&quot;279&quot; /&gt;&lt;/p&gt;

&lt;p&gt;将私钥保存为文件，保存时会提示你输入口令，命名为”PushChatKey.p12”。&lt;/p&gt;

&lt;p&gt;为了方便在本教程里引用，我使用”pushchat” 作为口令，实际应用时应该使用高强度的密码口令。可不能忘记口令，否则后面你可能无法访问私钥文件。&lt;/p&gt;

&lt;h2 id=&quot;idapp-idssl&quot;&gt;准备应用ID（App ID）和SSL证书&lt;/h2&gt;

&lt;p&gt;登入&lt;a href=&quot;https://developer.apple.com/ios/manage/overview/index.action&quot;&gt;苹果开发者门户&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;首先，我们先填写一个新的应用ID，每个推送通知服务都对应着唯一的应用，在这里，你不能使用通配符。&lt;/p&gt;

&lt;p&gt;在左项菜单中选择APP IDs，点击按钮【New App ID】。&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;Creating a new App ID&quot; src=&quot; /images/2014/Provisioning-1-New-AppID-500x389.jpg&quot; alt=&quot;Creating a new App ID&quot; width=&quot;500&quot; height=&quot;389&quot; /&gt;&lt;/p&gt;

&lt;p&gt;填写如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Description: PushChat&lt;/li&gt;
  &lt;li&gt;Bundle Seed ID: Generate New (this is the default option)&lt;/li&gt;
  &lt;li&gt;Bundle Identifier: com.hollance.PushChat&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里你得填上自己的标识：com.yoursite.PushChat，因为你在XCODE得用同样的标识开发应用。&lt;/p&gt;

&lt;p&gt;稍等一会，你就可以生成对应这个APP的SSL证书，你的服务组件通过这个证书也只能发送通知到这个APP。&lt;/p&gt;

&lt;p&gt;填写完毕，你应该可以看到下列信息：&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;List of App IDs in the iOS Provisioning Portal&quot; src=&quot; /images/2014/Provisioning-2-List-of-AppIDs-500x50.jpg&quot; alt=&quot;List of App IDs in the iOS Provisioning Portal&quot; width=&quot;500&quot; height=&quot;50&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在【Apple Push Notification service】列，有两行有橙色小圆点起始的信息：【Configurable for Development】 和【Configurable for Production】。 这就意味着这个应用ID已经准备好了，接下来设置相关的选项。点击【Configure】链接。&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;Configuring your App ID in the iOS Provisioning Portal&quot; src=&quot; /images/2014/Provisioning-3-Configure-AppID-500x350.jpg&quot; alt=&quot;Configuring your App ID in the iOS Provisioning Portal&quot; width=&quot;500&quot; height=&quot;350&quot; /&gt;&lt;/p&gt;

&lt;p&gt;点选【Enable for Apple Push Notification service】框，点击对应【Development Push SSL Certificate】的设置按钮 【Configure】，弹出 苹果推送服务SSL证书助理（Apple Push Notification service SSL Certificate Assistant）窗口 :&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;Uploading your CSR with the SSL Assistant&quot; src=&quot; /images/2014/SSL-Assistant-1-Upload-CSR-500x453.jpg&quot; alt=&quot;Uploading your CSR with the SSL Assistant&quot; width=&quot;500&quot; height=&quot;453&quot; /&gt;&lt;/p&gt;

&lt;p&gt;首先提示你准备好证书签名申请文件，我们上面已经准备好了，点击继续，在下一步中进行上传CSR文件的操作，选中之前生成的CSR文件然后点击生成（Generate）。&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;Generating a Certificate with the SSL Assistant&quot; src=&quot; /images/2014/SSL-Assistant-2-Generating-Certificate-500x456.jpg&quot; alt=&quot;Generating a Certificate with the SSL Assistant&quot; width=&quot;500&quot; height=&quot;456&quot; /&gt;&lt;/p&gt;

&lt;p&gt;生成证书需要几秒钟，接着点继续按钮（Continue）。&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;Downloading a certificate with the SSL assistant&quot; src=&quot; /images/2014/SSL-Assistant-3-Download-Certificate-500x455.jpg&quot; alt=&quot;Downloading a certificate with the SSL assistant&quot; width=&quot;500&quot; height=&quot;455&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下载生成的证书并保存为”aps_developer_identity.cer”。点击完成按钮（Done）关闭助理窗口返回APP ID界面。&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;Screenshot after the SSL Assistant is Complete&quot; src=&quot; /images/2014/Provisioning-4-After-SSL-Assistant-500x111.jpg&quot; alt=&quot;Screenshot after the SSL Assistant is Complete&quot; width=&quot;500&quot; height=&quot;111&quot; /&gt;&lt;/p&gt;

&lt;p&gt;你可以看到，我们已经激活开发用的证书认证，如果需要你可以在这里重新下载证书，开发证书的有效期为3个月。&lt;/p&gt;

&lt;p&gt;等你要正式发布你的应用的时候，你必须在开发认证那一项目下把这个过程重新来一遍。&lt;/p&gt;

&lt;p&gt;备注：开发认证的证书有效期为一年，你必须在到期前重新生成一次来保证你的系统正常运行。&lt;/p&gt;

&lt;p&gt;在本例中你不需要安装这个证书，如果你双击文件进行了安装，你可以在钥匙串访问程序中查找到，这个证书已经和私钥绑定在一起了。&lt;/p&gt;

&lt;h2 id=&quot;pem&quot;&gt;制作PEM文件&lt;/h2&gt;

&lt;p&gt;现在我们有三个文件：&lt;/p&gt;

&lt;p&gt;*认证签名申请文件（CSR）
*私钥文件（PushChatKey.p12）
*SSL证书文件（aps_developer_identity.cer）&lt;/p&gt;

&lt;p&gt;妥善地保存好这三个文件，特别是CSR文件，在你的证书失效之后，你可能会再次用到它来申请证书。原来的私钥还可以用，只有SSL证书文件是新的。&lt;/p&gt;

&lt;p&gt;我们需要转换证书和私钥文件为一种常用格式，示例中我们使用PHP开发服务组件，我们需要把证书和私钥文件合并为PEM格式文件。&lt;/p&gt;

&lt;p&gt;我们不用关心是哪一种具体的PEM编码格式（实际上我也不是很清楚），关键是PHP可以用来与服务器建立有效的网络连接，其他的编程语言可能会用到其它格式的文件。&lt;/p&gt;

&lt;p&gt;在这里，我们用MAC电脑的命令行工具OpenSSL来操作，打开一个”终端”（Terminal）程序：&lt;/p&gt;

&lt;p&gt;通过cd命令转到存放三个文件的文件夹，我这里的操作是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd /Users/matthijs/Desktop
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;转换证书 .cer 文件到 .pem 文件格式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ openssl x509 -in aps_developer_identity.cer -inform der -outPushChatCert.pem
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;转换私钥 .p12 文件 到 .pem 文件格式:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ openssl pkcs12 -nocerts -outPushChatKey.pem -inPushChatKey.p12
EnterImportPassword:
MAC verified OK
Enter PEM pass phrase:Verifying-Enter PEM pass phrase:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这里，你首先要输入私钥文件的口令以便访问.p12文件，接着要求输入一次新的口令来加密新的PEM文件，这里我们都用”pushchat” ，你也可以使用更复杂的口令来保护你的私钥。&lt;/p&gt;

&lt;p&gt;备注：如果你不输入一个6位以上的加密口令，openssl工具将给出错误信息并取消操作。&lt;/p&gt;

&lt;p&gt;最后，我们把这两个文件合并成一个 .pem 文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat PushChatCert.pem PushChatKey.pem &amp;gt; ck.pem
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;想测试一下证书是否正常，来试一下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ telnet gateway.sandbox.push.apple.com 2195
Trying 17.172..232.226...
Connected to gateway.sandbox.push-apple.com.akadns.net.
Escape character is&#39;^]&#39;.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里是生成一个普通的网络连接，如果有上面的信息，说明你的电脑可以联上APNS服务器，按Ctrl+C关闭连接。&lt;/p&gt;

&lt;p&gt;如果有问题，你需要检查一下网络和防火墙的端口2195的设置。&lt;/p&gt;

&lt;p&gt;这次我们试一试用私钥和证书进行SSL加密连接：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ openssl s_client -connect gateway.sandbox.push.apple.com:2195 -cert PushChatCert.pem -key PushChatKey.pem
Enterpass phrase forPushChatKey.pem:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你应该可以看到接下来的整个输出，我们已经站在正确的起跑线上了。&lt;/p&gt;

&lt;p&gt;如果连接成功，你可以输入几个字符，当你按下回车，连接就断开了，连接失败的话也会有提示信息。&lt;/p&gt;

&lt;p&gt;特别提示你有两个不用的APNS服务器，一个用于测试的沙盒服务器，一个用于正式使用的服务器，我们制作的证书是用于测试的，所以上面的示例中我们使用的是沙盒服务器的地址。&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;准备配置文件&lt;/h2&gt;

&lt;p&gt;开发者门户上的操作还没有完，点击左项菜单上的【Provisioning】，点击【New Profile】新建一个配置文件。&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;Creating a Provisioning Profile in the iOS Provisioning Portal&quot; src=&quot; /images/2014/Provisioning-5-Create-Profile-500x293.jpg&quot; alt=&quot;Creating a Provisioning Profile in the iOS Provisioning Portal&quot; width=&quot;500&quot; height=&quot;293&quot; /&gt;&lt;/p&gt;

&lt;p&gt;填入如下内容：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;配置名称Profile Name: PushChat Development&lt;/li&gt;
  &lt;li&gt;证书（Certificates）:选中你的开发者证书&lt;/li&gt;
  &lt;li&gt;应用ID（App ID）: PushChat&lt;/li&gt;
  &lt;li&gt;设备（Devices）: 选中你的开发设备&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里的操作跟你之前的没有什么不用，只是具备推送功能的应用需要一个新配置文件来跟设置好的APP对应起来。&lt;/p&gt;

&lt;p&gt;点击发送按钮（Submit），新的配置文件就会重新生成，稍等片刻，再刷新页面即可下载新的配置文件（PushChat_Development.mobileprovision）。&lt;/p&gt;

&lt;p&gt;将配置文件下载并加载到XCode（双击或拖到XCode图标上）。&lt;/p&gt;

&lt;p&gt;准备正式发布前，你也要这样操作来准备用发布用的配置文件。&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;简单的示例应用&lt;/h2&gt;

&lt;p&gt;你还在吗？经历了这么多终于可以来点兴奋点的事情了，不过上面的这些过程是必不可少的，至少这些也不需要天天搞的，否则是会死人的，不是吗？
我们已经实现与沙盒服务器的加密网络连接，现在就让我们来实现推送通知的发送吧。&lt;/p&gt;

&lt;p&gt;打开你的XCode，选择【File】【New Project】，选择【View-based Application】点击继续：&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;Creating a View-Based Application with Xcode 4&quot; src=&quot; /images/2014/Basic-App-1-Xcode-Assistant-500x340.jpg&quot; alt=&quot;Creating a View-Based Application with Xcode 4&quot; width=&quot;500&quot; height=&quot;340&quot; /&gt;&lt;/p&gt;

&lt;p&gt;填入以下内容：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Product Name: PushChat&lt;/li&gt;
  &lt;li&gt;Company Identifier: com.hollance&lt;/li&gt;
  &lt;li&gt;Device Family: iPhone&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;根据你的实际情况填入应用名称和开发者标识，这里我们就填入”com.hollance.PushChat”。你应该填入跟你在开发者门户里填入的一致信息(com.yourname.PushChat)。&lt;/p&gt;

&lt;p&gt;完成新建项目的操作，打开PushChatAppDelegate.m，修改 didFinishLaunchingWithOptions 过程：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-(BOOL)application:(UIApplication*)application didFinishLaunchingWithOptions:(NSDictionary*)launchOptions
{
  self.window.rootViewController =self.viewController;
  [self.window makeKeyAndVisible];
  // 通知设备需要接收推送通知 Let the device know we want to receive push notifications
  [[UIApplication sharedApplication] registerForRemoteNotificationTypes:(UIRemoteNotificationTypeBadge|UIRemoteNotificationTypeSound|UIRemoteNotificationTypeAlert)];
  return YES;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用registerForRemoteNotificationTypes 通知系统应用是需要接收推送信息的。&lt;/p&gt;

&lt;p&gt;在你的设备上编译运行应用，模拟器是不支持推送信息的。XCode应该会自动选择配置文件，如果出现签名错误，你需要在 Code Signing build settings手动选择之前下载的配置文件。应用启动时会注册推送通知服务，弹出下面的确认窗口提示用户允许此应用接收推送通知服务。&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;A Simple iPhone App Requesting Permission to Deliver Notifications&quot; src=&quot; /images/2014/Basic-App-2-Allow-Notifications-333x500.jpg&quot; alt=&quot;A Simple iPhone App Requesting Permission to Deliver Notifications&quot; width=&quot;333&quot; height=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;p&gt;应用只会提示询问一次，如果用户选择接受，设备就一切就绪了。如果用户选择了拒绝，应用将永远无法接收到信息，用户可以在设备的设置项目中修改此项设定。&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;Viewing Push Notification Permissions in iPhone Settings&quot; src=&quot; /images/2014/Basic-App-3-Settings-1-333x500.jpg&quot; alt=&quot;Viewing Push Notification Permissions in iPhone Settings&quot; width=&quot;333&quot; height=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;p&gt;应用的名称将会添加到设置程序中的通知项目下，用户可以方便地在这里开启或关闭或自定义接收信息的种类和方式。&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;A single app&#39;s Push Notification Settings&quot; src=&quot; /images/2014/Basic-App-4-Settings-2-333x500.jpg&quot; alt=&quot;A single app&#39;s Push Notification Settings&quot; width=&quot;333&quot; height=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;p&gt;应用也可以通过程序来激活具体的提示方式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;UIRemoteNotificationType enabledTypes =[[UIApplication sharedApplication] enabledRemoteNotificationTypes];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有额外的一件事，为了发送信息到指定的手机，我们还需要一些操作：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-(void)application:(UIApplication*)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData*)deviceToken
{
    NSLog(@&quot;我的设备ID: %@&quot;, deviceToken);
}
-(void)application:(UIApplication*)application didFailToRegisterForRemoteNotificationsWithError:(NSError*)error
{
    NSLog(@&quot;注册失败，无法获取设备ID, 具体错误: %@&quot;, error);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当应用注册推送服务成功时，就可以获取用户设备识别ID（Token ID），这是对应你的设备一个32位的唯一编码，你可以理解为推送信息的地址。&lt;/p&gt;

&lt;p&gt;运行应用，在XCode的终端窗口你可以看到以下信息：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;我的设备ID:&amp;lt;740f4707 bebcf74f 9b7c25d4 8e335894 5f6aa01d a5ddb387 462c7eaf 61bb78ad&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;设备识别ID（Token ID）是加密的数据结构，储备在NSData对象中。这里你知道它是32位长度就够了，上面你看到的是64个16进制的字符，我们将使用这个格式，当然&amp;lt;&amp;gt;和空格要过滤掉。&lt;/p&gt;

&lt;p&gt;在模拟器中运行，didFailToRegisterForRemoteNotificationsWithError会返回错误：method will be called as push notifications are not supported in the simulator.&lt;/p&gt;

&lt;p&gt;应用准备好了，就差最后一件事了。&lt;/p&gt;

&lt;h2 id=&quot;section-7&quot;&gt;发送我们的推送通知&lt;/h2&gt;

&lt;p&gt;之前我们都谈到要有服务器或服务组件来实现推送通知的发送和管理，在这里，我们先不急着搭建服务器，这里有一个简单的PHP脚本用来建立到APNS的连接和发送测试信息到之前的设备上。&lt;/p&gt;

&lt;p&gt;你可以在MAC上直接使用：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://d1xzuxjlafny7l.cloudfront.net/downloads/SimplePush.zip&quot;&gt;下载SimplePush源代码&lt;/a&gt;，解开后，修改simplepush.php中的以下几个地方：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Put your device token here (without spaces):
$deviceToken =&#39;0f744707bebcf74f9b7c25d48e3358945f6aa01da5ddb387462c7eaf61bbad78&#39;;
// Put your private key&#39;s passphrase here:
$passphrase =&#39;pushchat&#39;;
// Put your alert message here:
$message =&#39;My first push notification!&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;复制设备识别ID到变量$deviceToken，别留下任何一个空格，完完全全就是64个16进制字符；指定私钥的口令和要发送的信息内容；复制ck.pem到脚本所在文件夹，ck.pem包括了证书和私钥。&lt;/p&gt;

&lt;p&gt;开启终端程序（ Terminal）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ php simplepush.php
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果一切OK的话，脚本将返回：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Connected to APNS
Message successfully delivered
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;几秒钟内，你应该可以在设备上收到推送的信息了。&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;Simple app receiving a Push Notification&quot; src=&quot; /images/2014/Basic-App-5-Success-333x500.jpg&quot; alt=&quot;Simple app receiving a Push Notification&quot; width=&quot;333&quot; height=&quot;500&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意如果应用在开启运行状态的话，你看不到任何信息，信息被直接发送给应用本身，但是我们还没有通过编程来处理收到的信息，不信你可以再试一下。&lt;/p&gt;

&lt;p&gt;如果PHP脚本退出并返回错误信息，请检查PEM文件是否正确、连接沙盒服务器是否正常。&lt;/p&gt;

&lt;p&gt;PHP脚本具体的实现过程就不讨论了，有兴趣的或需要自行搭建服务器来管理发送推送通知的可以看此教程的下篇（请找原出处）。&lt;/p&gt;

&lt;h2 id=&quot;section-8&quot;&gt;接下来呢&lt;/h2&gt;

&lt;p&gt;现在你已经成功地实现了应用的推送通知服务，在此教程的下篇中，我们来开发一个简单的短消息应用（PushChat）来实现用户之间的推送通知功能。还有完整用于在后台不间断提供推送通知服务的服务组件API。&lt;/p&gt;

&lt;p&gt;欢迎向我们提问交流，谢谢。&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;Matthijs Hollemans&quot; src=&quot; /images/2014/hollemans_100x100.jpg&quot; alt=&quot;Matthijs Hollemans&quot; width=&quot;100&quot; height=&quot;100&quot; /&gt;
作者： &lt;a href=&quot;http://twitter.com/#!/mhollemans&quot;&gt;Matthijs Hollemans&lt;/a&gt;，iOS 教程小组成员，高级iOS开发人员和设计人员。&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;Cheney Lin&quot; src=&quot;/images/lcy.png&quot; alt=&quot;Cheney Hollemans&quot; width=&quot;100&quot; height=&quot;100&quot; /&gt;
译者：&lt;a href=&quot;http://twitter.com/#!/linchangyu&quot;&gt;Cheney Lin&lt;/a&gt;, &lt;a href=&quot;http://www.linchangyu.com/&quot;&gt;linchangyu.com&lt;/a&gt;, 全栈开发者。&lt;/p&gt;
</description>
                <link>http://www.linchangyu.com/ios/2014/11/26/apple-push-notification-service</link>
                <guid>http://www.linchangyu.com/ios/2014/11/26/apple-push-notification-service</guid>
                <pubDate>2014-11-26T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>使用淘宝的备用源加快Ruby Gem的访问速度</title>
                <description>
&lt;p&gt;rubygems.org is slowly to visite in China, Use Taobao source to speen gem install.&lt;/p&gt;

&lt;p&gt;More information visit &lt;a href=&quot;http://ruby.taobao.org/&quot;&gt;http://ruby.taobao.org/&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;terminal-command&quot;&gt;Terminal Command&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$ gem source -l
*** CURRENT SOURCES ***

https://rubygems.org/
$ gem sources --remove http://rubygems.org/  
$ gem sources -a http://ruby.taobao.org/  
$ gem sources -l  
*** CURRENT SOURCES ***  

http://ruby.taobao.org  
# 请确保只有 ruby.taobao.org  
$ gem install jekyll
...
&lt;/code&gt;&lt;/pre&gt;
</description>
                <link>http://www.linchangyu.com/web/2014/11/25/ruby-gem-taobao-source</link>
                <guid>http://www.linchangyu.com/web/2014/11/25/ruby-gem-taobao-source</guid>
                <pubDate>2014-11-25T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>高性能移动HTML5应用开发框架Collie</title>
                <description>
&lt;p&gt;Sangmin is a Senior JavaScript developer working at NHN and the creator of the JavaScript animation library Collie.&lt;/p&gt;

&lt;p&gt;I use collie framework to developed some HTML5 game.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.adobe.com/cn/devnet/html5/articles/introducing-collie.html&quot;&gt;A intro from adobe.com&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;colliejs-framework&quot;&gt;COLLIEJS Framework&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://jindo.dev.naver.com/collie/index.html&quot;&gt;CollieJS&lt;/a&gt; is a javascript framework.&lt;/p&gt;

&lt;h1 id=&quot;classes&quot;&gt;Classes&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;Animation&lt;/li&gt;
  &lt;li&gt;AnimationCycle&lt;/li&gt;
  &lt;li&gt;AnimationDelay&lt;/li&gt;
  &lt;li&gt;AnimationQueue&lt;/li&gt;
  &lt;li&gt;AnimationRepeat&lt;/li&gt;
  &lt;li&gt;AnimationTimeline&lt;/li&gt;
  &lt;li&gt;AnimationTransition&lt;/li&gt;
  &lt;li&gt;Box2d&lt;/li&gt;
  &lt;li&gt;Circle&lt;/li&gt;
  &lt;li&gt;Component&lt;/li&gt;
  &lt;li&gt;ComponentEvent&lt;/li&gt;
  &lt;li&gt;DisplayObject&lt;/li&gt;
  &lt;li&gt;FPSConsole&lt;/li&gt;
  &lt;li&gt;ImageNumber&lt;/li&gt;
  &lt;li&gt;Layer&lt;/li&gt;
  &lt;li&gt;LayerEvent&lt;/li&gt;
  &lt;li&gt;Map&lt;/li&gt;
  &lt;li&gt;MovableObject&lt;/li&gt;
  &lt;li&gt;PathFinding&lt;/li&gt;
  &lt;li&gt;Polyline&lt;/li&gt;
  &lt;li&gt;Pool&lt;/li&gt;
  &lt;li&gt;Rectangle&lt;/li&gt;
  &lt;li&gt;Sensor&lt;/li&gt;
  &lt;li&gt;Text&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;namespaces&quot;&gt;Namespaces&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;collie&lt;/li&gt;
  &lt;li&gt;Effect&lt;/li&gt;
  &lt;li&gt;ImageManager&lt;/li&gt;
  &lt;li&gt;Matrix&lt;/li&gt;
  &lt;li&gt;Profiling&lt;/li&gt;
  &lt;li&gt;Renderer&lt;/li&gt;
  &lt;li&gt;Timer&lt;/li&gt;
  &lt;li&gt;Transform&lt;/li&gt;
  &lt;li&gt;util&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;More information visit &lt;a href=&quot;http://jindo.dev.naver.com/collie/doc/index.html?l=en&quot;&gt;Api Refence&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;sample-code&quot;&gt;Sample Code&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&quot;container&quot;&amp;gt;&amp;lt;/div&amp;gt;

&amp;lt;!-- Load a script --&amp;gt;
&amp;lt;script type=&quot;text/javascript&quot; src=&quot;http://jindo.dev.naver.com/collie/deploy/collie.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
// Load the logo.png image
collie.ImageManager.add({
    &quot;logo&quot; : &quot;http://jindo.dev.naver.com/collie/img/small/logo.png&quot;
});

// Create a layer
var layer = new collie.Layer({
    width : 240,
    height : 240
});

// Create an object that will be displayed on the screen
var item = new collie.DisplayObject({
    x : &quot;center&quot;,
    y : &quot;center&quot;,
    velocityRotate : 180,
    backgroundImage : &quot;logo&quot; // The background image is re-sized to the pre-loaded logo.png size
}).addTo(layer); // Add to a layer

// Add a layer to renderer
collie.Renderer.addLayer(layer);

// Retrieve renderer from the container ID element
collie.Renderer.load(document.getElementById(&quot;container&quot;));

// Start rendering
collie.Renderer.start();
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;div id=&quot;container&quot;&gt;&lt;/div&gt;

&lt;!-- Load a script --&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;http://jindo.dev.naver.com/collie/deploy/collie.min.js&quot;&gt;&lt;/script&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
// Load the logo.png image
collie.ImageManager.add({
    &quot;logo&quot; : &quot;/images/collie.png&quot;
});

// Create a layer
var layer = new collie.Layer({
    width : 240,
    height : 240
});

// Create an object that will be displayed on the screen
var item = new collie.DisplayObject({
    x : &quot;center&quot;,
    y : &quot;center&quot;,
    velocityRotate : 180,
    backgroundImage : &quot;logo&quot; // The background image is re-sized to the pre-loaded logo.png size
}).addTo(layer); // Add to a layer

// Add a layer to renderer
collie.Renderer.addLayer(layer);

// Retrieve renderer from the container ID element
collie.Renderer.load(document.getElementById(&quot;container&quot;));

// Start rendering
collie.Renderer.start();
&lt;/script&gt;

&lt;h2 id=&quot;basic-usages&quot;&gt;Basic Usages&lt;/h2&gt;

&lt;p&gt;1.Make your layer for contain objects.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;collie.Layer&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var layer = new collie.Layer();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.Make Object for display on layer.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;collie.DisplayObject&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Use MovableObject if you want to use velocity or force attributes.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;collie.MovableObject&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Other objects extends collie.DisplayObject&lt;/p&gt;

&lt;p&gt;&lt;em&gt;collie.Text&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;collie.Circle&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;collie.Polyline&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;collie.Rectangle&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Make sure that you should be append object to layer after make object.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;new collie.DisplayObject().addTo(layer);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.You can load image for make stylish animation..&lt;/p&gt;

&lt;p&gt;&lt;em&gt;collie.ImageManager&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;collie.ImageManager.add({
	sample : &quot;image.png&quot;,
	sample2 : &quot;image2.png&quot;
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4.If you want to animate objects, you can use collie.Timer&lt;/p&gt;

&lt;p&gt;&lt;em&gt;collie.Timer&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;collie.Timer is just initializer. you can find more detail description here.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;collie.Timer.repeat()&lt;/li&gt;
  &lt;li&gt;collie.Timer.delay()&lt;/li&gt;
  &lt;li&gt;collie.Timer.cycle()&lt;/li&gt;
  &lt;li&gt;collie.Timer.transition()&lt;/li&gt;
  &lt;li&gt;collie.Timer.queue()&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;collie.Timer.timeline()&lt;/p&gt;

    &lt;p&gt;collie.Timer.cycle(oDisplayObject, 1000, {
 	to : 10,
 	loop : 3
 });&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;5.You can use event if you want to run callback when occurs user action.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;collie.DisplayObject&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;collie.Layer&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;new collie.DisplayObject().attach({
	click : function (e) {
		console.log(e.x, e.y);
	}
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;6.Renderer can help for start animation if you are ready to run.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;collie.Renderer&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;collie.Renderer.addLayer(layer);
collie.Renderer.load(document.getElementById(&quot;container&quot;));
collie.Renderer.start();
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;demos&quot;&gt;Demos&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://jindo.dev.naver.com/collie/demo/drag/&quot;&gt;drag&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://jindo.dev.naver.com/collie/demo/box2d/&quot;&gt;box2d&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://jindo.dev.naver.com/collie/index.html&quot;&gt;more on http://jindo.dev.naver.com/collie/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;works&quot;&gt;Works&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://mgtv.sinaapp.com/jphn/&quot;&gt;JingPaiHongNian&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
                <link>http://www.linchangyu.com/web/2014/11/25/collie-js-framework</link>
                <guid>http://www.linchangyu.com/web/2014/11/25/collie-js-framework</guid>
                <pubDate>2014-11-25T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>大陆常用网站开发开源资源加速公共库</title>
                <description>
&lt;p&gt;In China, Googleapis.com is can not visite, I must use these services.&lt;/p&gt;

&lt;h2 id=&quot;sae&quot;&gt;SAE&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://lib.sinaapp.com/&quot;&gt;lib.sinaapp.com&lt;/a&gt;, supports these products.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;bootstrap&lt;/li&gt;
  &lt;li&gt;jquery&lt;/li&gt;
  &lt;li&gt;jquery.cookie&lt;/li&gt;
  &lt;li&gt;jquery-ui&lt;/li&gt;
  &lt;li&gt;zepto&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;and webfont too.&lt;/p&gt;

&lt;h2 id=&quot;baidu&quot;&gt;BAIDU&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://developer.baidu.com/wiki/index.php?title=docs/cplat/libs&quot;&gt;developer.baidu.com&lt;/a&gt;, almost supports.&lt;/p&gt;

&lt;p&gt;but there are someone pointed out baidu used cookie to do some dirty works.&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;360&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://libs.useso.com/&quot;&gt;useso.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Other good chioce.&lt;/p&gt;
</description>
                <link>http://www.linchangyu.com/web/2014/11/24/chinese-public-web-lib</link>
                <guid>http://www.linchangyu.com/web/2014/11/24/chinese-public-web-lib</guid>
                <pubDate>2014-11-24T00:00:00+08:00</pubDate>
        </item>


</channel>
</rss>
