
<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <title>jQuery UI 插件入门</title>
    <link rel="apple-touch-icon" href="/images/lcy.png" />
    <link rel="apple-touch-icon" sizes="72x72" href="/images/lcy.png" />
    <link rel="apple-touch-icon" sizes="114x114" href="/images/lcy.png" />
    <meta name="description" content="【教程】jQuery UI 插件入门">
    <meta name="keyword" content="疯狂填字,芒果轻应用,麒麟工作室,林长宇">
    <meta name="author" content="老林">

    <!-- Enable responsive viewport -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Bootstrap styles -->
    <link href="/assets/themes/bootstrap-3/bootstrap/css/bootstrap.min.css" rel="stylesheet">
    <!-- Optional theme -->
    <link href="/assets/themes/bootstrap-3/bootstrap/css/bootstrap-theme.min.css" rel="stylesheet">
    <!-- Sticky Footer -->
    <link href="/assets/themes/bootstrap-3/bootstrap/css/bs-sticky-footer.css" rel="stylesheet">

    <!-- Custom styles -->
    <link href="/assets/themes/bootstrap-3/css/style.css?body=1" rel="stylesheet" type="text/css" media="all">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->

    <!-- Fav and touch icons -->
    <!-- Update these with your own images
      <link rel="shortcut icon" href="images/favicon.ico">
      <link rel="apple-touch-icon" href="images/apple-touch-icon.png">
      <link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png">
      <link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png">
    -->

    <!-- atom & rss feed -->
    <link href="/atom.xml" type="application/atom+xml" rel="alternate" title="Sitewide ATOM Feed">
    <link href="/rss.xml" type="application/rss+xml" rel="alternate" title="Sitewide RSS Feed">

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?4785b99b80e16b513797fed0b7f9237d";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>

  </head>

  <body>
    <div id="wrap">
      <nav class="navbar navbar-default" role="navigation">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#jb-navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="/"><img src="/images/lcy.png" width="64" height="64">风雨雷电堂</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="jb-navbar-collapse">
          <ul class="nav navbar-nav">
            
            
            


  
    
      
      	
      	<li><a href="/archive.html">日志</a></li>
      	
      
    
  
    
      
    
  
    
      
      	
      	<li><a href="/categories.html">分类</a></li>
      	
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
    
  
    
      
      	
      	<li><a href="/projects.html">项目</a></li>
      	
      
    
  
    
      
    
  
    
      
    
  
    
      
      	
      	<li><a href="/tags.html">标签</a></li>
      	
      
    
  




          </ul>
          <form class="navbar-form navbar-right" role="search" action="http://zhannei.baidu.com/cse/search" method="get" target="_blank">
          <input type="hidden" name="s" value="10670906174234479444"> <input type="hidden" name="entry" value="1">
            <div class="form-group">
              <input name="q" type="text" class="form-control" placeholder="Search">
            </div>
            <button type="submit" class="btn btn-default">Submit</button>
          </form>
        </div><!-- /.navbar-collapse -->
      </nav>

      <div class="container">
        
<div class="page-header">
  <h1>jQuery UI 插件入门 <small>【教程】</small></h1>
</div>

<div class="row post-full">
  <div class="col-xs-12">
    <div class="date">
      <span>2014年12月12日</span>
    </div>
    <div class="content">
      
<h2 id="how-to-use-the-widget-factory">How To Use the Widget Factory</h2>

<p>To start, we’ll create a progress bar that just lets us set the progress once. As we can see below, this is done by calling jQuery.widget() with two parameters: the name of the plugin to create, and an object literal containing functions to support our plugin. When our plugin gets called, it will create a new plugin instance and all functions will be executed within the context of that instance. This is different from a standard jQuery plugin in two important ways. First, the context is an object, not a DOM element. Second, the context is always a single object, never a collection.</p>

<pre><code>$.widget( "custom.progressbar", {
  _create: function() {
    var progress = this.options.value + "%";
    this.element
    .addClass( "progressbar" )
    .text( progress );
  }
  });
</code></pre>

<p>The name of the plugin must contain a namespace, in this case we’ve used the custom namespace. You can only create namespaces that are one level deep, therefore, custom.progressbar is a valid plugin name whereas very.custom.progressbar is not.</p>

<p>We can also see that the widget factory has provided two properties for us. this.element is a jQuery object containing exactly one element. If our plugin is called on a jQuery object containing multiple elements, a separate plugin instance will be created for each element, and each instance will have its own this.element. The second property, this.options, is a hash containing key/value pairs for all of our plugin’s options. These options can be passed to our plugin as shown here.</p>

<p>$( “&lt;div&gt;&lt;/div&gt;” ).appendTo( “body” ).progressbar({ value: 20 });</p>

<p>When we call jQuery.widget() it extends jQuery by adding a function to jQuery.fn (the system for creating a standard plugin). The name of the function it adds is based on the name you pass to jQuery.widget(), without the namespace - in our case “progressbar”. The options passed to our plugin are the values that get set in this.options inside of our plugin instance. As shown below, we can specify default values for any of our options. When designing your API, you should figure out the most common use case for your plugin so that you can set appropriate default values and make all options truly optional.</p>

<pre><code>$.widget( "custom.progressbar", {
// Default options.
options: {
  value: 0
  },
  _create: function() {
    var progress = this.options.value + "%";
    this.element
    .addClass( "progressbar" )
    .text( progress );
  }
  });
</code></pre>

<h2 id="calling-plugin-methods">Calling Plugin Methods</h2>

<p>Now that we can initialize our progress bar, we’ll add the ability to perform actions by calling methods on our plugin instance. To define a plugin method, we just include the function in the object literal that we pass to jQuery.widget(). We can also define “private” methods by prepending an underscore to the function name.</p>

<pre><code>  $.widget( "custom.progressbar", {

    options: {
      value: 0
      },

      _create: function() {
        var progress = this.options.value + "%";
        this.element
        .addClass( "progressbar" )
        .text( progress );
        },

        // Create a public method.
        value: function( value ) {

          // No value passed, act as a getter.
          if ( value === undefined ) {
            return this.options.value;
          }

          // Value passed, act as a setter.
          this.options.value = this._constrain( value );
          var progress = this.options.value + "%";
          this.element.text( progress );
          },

          // Create a private method.
          _constrain: function( value ) {
            if ( value &gt; 100 ) {
              value = 100;
            }
            if ( value &lt; 0 ) {
              value = 0;
            }
            return value;
          }
          });
</code></pre>

<p>To call a method on a plugin instance, you pass the name of the method to the jQuery plugin. If you are calling a method that accepts parameters, you simply pass those parameters after the method name.</p>

<p>Note: Executing methods by passing the method name to the same jQuery function that was used to initialize the plugin may seem odd. This is done to prevent pollution of the jQuery namespace while maintaining the ability to chain method calls. Later in this article we’ll see alternative uses that may feel more natural.</p>

<pre><code>          var bar = $( "&lt;div&gt;&lt;/div&gt;" )
          .appendTo( "body" )
          .progressbar({ value: 20 });

          // Get the current value.
          alert( bar.progressbar( "value" ) );

          // Update the value.
          bar.progressbar( "value", 50 );

          // Get the current value again.
          alert( bar.progressbar( "value" ) );
</code></pre>

<h2 id="working-with-options">Working with Options</h2>

<p>One of the methods that are automatically available to our plugin is the option() method. The option() method allows you to get and set options after initialization. This method works exactly like jQuery’s .css() and .attr() methods: You can pass just a name to use it as a getter, a name and value to use it as a single setter, or a hash of name/value pairs to set multiple values. When used as a getter, the plugin will return the current value of the option that corresponds to the name that was passed in. When used as a setter, the plugin’s _setOption method will be called for each option that is being set. We can specify a _setOption method in our plugin to react to option changes. For actions to perform independent of the number of options changed, we can override _setOptions().</p>

<pre><code>  $.widget( "custom.progressbar", {
    options: {
      value: 0
      },
      _create: function() {
        this.options.value = this._constrain(this.options.value);
        this.element.addClass( "progressbar" );
        this.refresh();
        },
        _setOption: function( key, value ) {
          if ( key === "value" ) {
            value = this._constrain( value );
          }
          this._super( key, value );
          },
          _setOptions: function( options ) {
            this._super( options );
            this.refresh();
            },
            refresh: function() {
              var progress = this.options.value + "%";
              this.element.text( progress );
              },
              _constrain: function( value ) {
                if ( value &gt; 100 ) {
                  value = 100;
                }
                if ( value &lt; 0 ) {
                  value = 0;
                }
                return value;
              }
              });
</code></pre>

<h2 id="adding-callbacks">Adding Callbacks</h2>

<p>One of the easiest ways to make your plugin extensible is to add callbacks so users can react when the state of your plugin changes. We can see below how to add a callback to our progress bar to signify when the progress has reached 100%. The _trigger() method takes three parameters: the name of the callback, a jQuery event object that initiated the callback, and a hash of data relevant to the event. The callback name is the only required parameter, but the others can be very useful for users who want to implement custom functionality on top of your plugin. For example, if we were building a draggable plugin, we could pass the mousemove event when triggering a drag callback; this would allow users to react to the drag based on the x/y coordinates provided by the event object. Note that the original event passed to _trigger() must be a jQuery event, not a native browser event.</p>

<pre><code>  $.widget( "custom.progressbar", {
    options: {
      value: 0
      },
      _create: function() {
        this.options.value = this._constrain(this.options.value);
        this.element.addClass( "progressbar" );
        this.refresh();
        },
        _setOption: function( key, value ) {
          if ( key === "value" ) {
            value = this._constrain( value );
          }
          this._super( key, value );
          },
          _setOptions: function( options ) {
            this._super( options );
            this.refresh();
            },
            refresh: function() {
              var progress = this.options.value + "%";
              this.element.text( progress );
              if ( this.options.value == 100 ) {
                this._trigger( "complete", null, { value: 100 } );
              }
              },
              _constrain: function( value ) {
                if ( value &gt; 100 ) {
                  value = 100;
                }
                if ( value &lt; 0 ) {
                  value = 0;
                }
                return value;
              }
              });
</code></pre>

<p>Callback functions are essentially just additional options, so you can get and set them just like any other option. Whenever a callback is executed, a corresponding event is triggered as well. The event type is determined by concatenating the plugin name and the callback name. The callback and event both receive the same two parameters: an event object and a hash of data relevant to the event, as we’ll see below. Your plugin may have functionality that you want to allow the user to prevent. The best way to support this is by creating cancelable callbacks. Users can cancel a callback, or its associated event, the same way they cancel any native event, by calling event.preventDefault() or returning false. If the user cancels the callback, the _trigger() method will return false so you can implement the appropriate functionality within your plugin.</p>

<pre><code>var bar = $( "&lt;div&gt;&lt;/div&gt;" )
.appendTo( "body" )
.progressbar({
  complete: function( event, data ) {
    alert( "Callbacks are great!" );
  }
  })
  .bind( "progressbarcomplete", function( event, data ) {
    alert( "Events bubble and support many handlers for extreme flexibility." );
    alert( "The progress bar value is " + data.value );
    });

    bar.progressbar( "option", "value", 100 );
</code></pre>

<h2 id="looking-under-the-hood">Looking Under the Hood</h2>

<p>Now that we’ve seen how to build a plugin using the widget factory, let’s take a look at how it actually works. When you call jQuery.widget(), it creates a constructor for your plugin and sets the object literal that you pass in as the prototype for your plugin instances. All of the functionality that automatically gets added to your plugin comes from a base widget prototype, which is defined as jQuery.Widget.prototype. When a plugin instance is created, it is stored on the original DOM element using jQuery.data, with the plugin name as the key.</p>

<p>Because the plugin instance is directly linked to the DOM element, you can access the plugin instance directly instead of going through the exposed plugin method if you want. This will allow you to call methods directly on the plugin instance instead of passing method names as strings and will also give you direct access to the plugin’s properties.</p>

<pre><code>  var bar = $( "&lt;div&gt;&lt;/div&gt;" )
  .appendTo( "body" )
  .progressbar()
  .data( "custom-progressbar" );

  // Call a method directly on the plugin instance.
  bar.option( "value", 50 );

  // Access properties on the plugin instance.
  alert( bar.options.value );
</code></pre>

<p>You can also create an instance without going through the plugin method, by calling the constructor directly, with the options and element arguments:</p>

<pre><code>var bar = $.custom.progressbar( {}, $( "&lt;div&gt;&lt;/div&gt;" ).appendTo( "body") );

// Same result as before.
alert( bar.options.value );
</code></pre>

<h2 id="extending-a-plugins-prototype">Extending a Plugin’s Prototype</h2>

<p>One of the biggest benefits of having a constructor and prototype for a plugin is the ease of extending the plugin. By adding or modifying methods on the plugin’s prototype, we can modify the behavior of all instances of our plugin. For example, if we wanted to add a method to our progress bar to reset the progress to 0% we could add this method to the prototype and it would instantly be available to be called on any plugin instance.</p>

<pre><code>  $.custom.progressbar.prototype.reset = function() {
    this._setOption( "value", 0 );
  };
</code></pre>

<p>For more information on extending widgets, including how to build entirely new widgets on top of existing ones, see Extending Widgets with the Widget Factory.</p>

<h2 id="cleaning-up">Cleaning Up</h2>

<p>In some cases, it will make sense to allow users to apply and then later unapply your plugin. You can accomplish this via the _destroy() method. Within the _destroy() method, you should undo anything your plugin may have done during initialization or later use. _destroy() is called by the destroy() method, which is automatically called if the element that your plugin instance is tied to is removed from the DOM, so this can be used for garbage collection as well. That base destroy() method also handles some general cleanup operations, like removing the instance reference from the widget’s DOM element, unbinding all events in the widget’s namespace from the element, and unbinding generally all events that were added using _bind().</p>

<pre><code>$.widget( "custom.progressbar", {
options: {
value: 0
},
_create: function() {
this.options.value = this._constrain(this.options.value);
this.element.addClass( "progressbar" );
this.refresh();
},
_setOption: function( key, value ) {
  if ( key === "value" ) {
    value = this._constrain( value );
  }
  this._super( key, value );
  },
  _setOptions: function( options ) {
    this._super( options );
    this.refresh();
    },
    refresh: function() {
      var progress = this.options.value + "%";
      this.element.text( progress );
      if ( this.options.value == 100 ) {
        this._trigger( "complete", null, { value: 100 } );
      }
      },
      _constrain: function( value ) {
        if ( value &gt; 100 ) {
          value = 100;
        }
        if ( value &lt; 0 ) {
          value = 0;
        }
        return value;
        },
        _destroy: function() {
          this.element
          .removeClass( "progressbar" )
          .text( "" );
        }
        });
</code></pre>

<h2 id="closing-comments">Closing Comments</h2>

<p>The widget factory is only one way of creating stateful plugins. There are a few different models that can be used and each have their own advantages and disadvantages. The widget factory solves lots of common problems for you and can greatly improve productivity, it also greatly improves code reuse, making it a great fit for jQuery UI as well as many other stateful plugins.</p>

<p>You may have noticed that in this article we used the custom namespace. The ui namespace is reserved for official jQuery UI plugins. When building your own plugins, you should create your own namespace. This makes it clear where the plugin came from and if it is part of a larger collection.</p>

<p><em>http://learn.jquery.com/jquery-ui/widget-factory/how-to-use-the-widget-factory/</em></p>

    </div>

  
    <ul class="tag_box inline">
      <li><i class="glyphicon glyphicon-open"></i></li>
      
      


  
     
    	<li><a href="/categories.html#web-ref">
    		web <span>8</span>
    	</a></li>
    
  


    </ul>
  

  
    <ul class="tag_box inline">
      <li><i class="glyphicon glyphicon-tags"></i></li>
      
      


  
     
    	<li><a href="/tags.html#jQuery-ref">jQuery <span>2</span></a></li>
     
    	<li><a href="/tags.html#javascript-ref">javascript <span>2</span></a></li>
    
  



    </ul>
  

    <hr>
    <ul class="pagination">
    
      <li class="prev"><a href="/web/2014/12/12/jquery-ui-widget-extending-guide" title="jQuery UI 插件扩展">上一篇</a></li>
    
      <li><a href="/archive.html">归档</a></li>
    
      <li class="next"><a href="/app/2014/12/29/android-third-app-package-guide" title="安卓第三方应用调起常见问题">下一篇</a></li>
    
    </ul>
    <hr>
    


  <div class="ds-thread" data-thread-key="/web/2014/12/12/jquery-ui-widget-factory-guide" data-title="jQuery UI 插件入门" data-url="http://www.linchangyu.com/web/2014/12/12/jquery-ui-widget-factory-guide"></div>
<script type="text/javascript">
var duoshuoQuery = {short_name:"linchangyu"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>




  </div>
</div>


      </div>
      <div class="container">
        <div class="bdsharebuttonbox"><a href="#" class="bds_more" data-cmd="more"></a><a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a><a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a><a href="#" class="bds_tqq" data-cmd="tqq" title="分享到腾讯微博"></a><a href="#" class="bds_renren" data-cmd="renren" title="分享到人人网"></a><a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a></div>
        <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"32"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>
      </div>
    </div>

    <div id="footer">
      <div class="container">
        <p>&copy; 2015 老林 with <a href="http://jekyllbootstrap.com" target="_blank" title="The Definitive Jekyll Blogging Framework">Jekyll Bootstrap</a>
        </p>
      </div>
    </div>
    



    <!-- Latest compiled and minified JavaScript, requires jQuery 1.x (2.x not supported in IE8) -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="http://lib.sinaapp.com/js/jquery/2.0.3/jquery-2.0.3.min.js"></script>
    <script src="/assets/themes/bootstrap-3/bootstrap/js/bootstrap.min.js"></script>
  </body>
</html>

